using System.Net;
using System.Net.Http.Json;
using UrlShortener.App.Shared.Dto;
using UrlShortener.App.Shared.Models;
using UrlShortener.Test.End2End.Base;
using UrlShortener.Test.End2End.Data;

namespace UrlShortener.Test.End2End.Tests.PenTests
{
    [TestFixture]
    public class RegisterPenTest : PlayWrightFullTestBase
    {
        private HttpClient _httpClient;
        protected override List<User> TestUsers => TestData.GetDefaultTestUsers();

        private static string GenerateRandomEmail() => $"user_{Guid.NewGuid():N}@test.com";

        [OneTimeSetUp]
        public void Setup()
        {
            _httpClient = new HttpClient()
            {
                BaseAddress = new Uri(BackendTest.Url)
            };
        }

        [Test]
        public async Task Register_WithValidInput_ShouldSucceed()
        {
            var request = new RegisterRequestDto
            {
                Email = GenerateRandomEmail(),
                Password = "SecurePass123"
            };

            var response = await _httpClient.PostAsJsonAsync("/api/auth/register", request);
            var content = await response.Content.ReadFromJsonAsync<RegisterResponseDto>();

            Assert.Multiple(() =>
            {
                Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.OK));
                Assert.That(content?.Success, Is.True);
            });
        }

        [Test]
        public async Task Register_WithExistingEmail_ShouldReturnConflict()
        {
            var email = GenerateRandomEmail();

            // First registration (OK)
            var first = new RegisterRequestDto { Email = email, Password = "Test1234" };
            await _httpClient.PostAsJsonAsync("/api/auth/register", first);

            // Second registration (Conflict)
            var second = new RegisterRequestDto { Email = email, Password = "Test1234" };
            var response = await _httpClient.PostAsJsonAsync("/api/auth/register", second);
            var body = await response.Content.ReadFromJsonAsync<RegisterResponseDto>();

            Assert.Multiple(() =>
            {
                Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.Conflict));
                Assert.That(body?.ErrorType, Is.EqualTo(RegisterErrorType.EmailAlreadyExists));
            });
        }

        [Test]
        public async Task Register_WithEmptyFields_ShouldReturnBadRequest()
        {
            var request = new RegisterRequestDto { Email = "", Password = "" };
            var response = await _httpClient.PostAsJsonAsync("/api/auth/register", request);
            var content = await response.Content.ReadFromJsonAsync<RegisterResponseDto>();

            Assert.Multiple(() =>
            {
                Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.BadRequest));
                Assert.That(content?.ErrorType, Is.EqualTo(RegisterErrorType.MissingEmailOrPassword));
            });
        }

        [Test]
        public async Task Register_WithInvalidEmail_ShouldReturnBadRequest()
        {
            var request = new RegisterRequestDto
            {
                Email = "not-an-email",
                Password = "Test1234"
            };

            var response = await _httpClient.PostAsJsonAsync("/api/auth/register", request);
            var content = await response.Content.ReadFromJsonAsync<RegisterResponseDto>();

            Assert.Multiple(() =>
            {
                Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.BadRequest));
                Assert.That(content?.ErrorType, Is.EqualTo(RegisterErrorType.MissingEmailOrPassword));
            });
        }

        [Test]
        public async Task Register_WithShortPassword_ShouldReturnBadRequest()
        {
            var request = new RegisterRequestDto
            {
                Email = GenerateRandomEmail(),
                Password = "123"
            };

            var response = await _httpClient.PostAsJsonAsync("/api/auth/register", request);
            var content = await response.Content.ReadFromJsonAsync<RegisterResponseDto>();

            Assert.Multiple(() =>
            {
                Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.BadRequest));
                Assert.That(content?.ErrorType, Is.EqualTo(RegisterErrorType.PasswordPolicyViolation));
            });
        }

        [Test]
        public async Task Register_WithSqlInjection_ShouldReturnBadRequestOrUnauthorized()
        {
            var request = new RegisterRequestDto
            {
                Email = "' OR 1=1 --@test.com",
                Password = "doesntmatter"
            };

            var response = await _httpClient.PostAsJsonAsync("/api/auth/register", request);

            Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.BadRequest)
                                             .Or.EqualTo(HttpStatusCode.Conflict));
        }

        [Test]
        public async Task Register_WithVeryLongEmail_ShouldReturnBadRequestOrConflict()
        {
            var longEmail = new string('A', 10000) + "@test.com";

            var request = new RegisterRequestDto
            {
                Email = longEmail,
                Password = "ValidPassword123"
            };

            var response = await _httpClient.PostAsJsonAsync("/api/auth/register", request);
            Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.BadRequest)
                                             .Or.EqualTo(HttpStatusCode.Conflict));
        }

        [Test]
        public async Task Register_WithEmoji_ShouldReturnSuccessOrBadRequest()
        {
            var request = new RegisterRequestDto
            {
                Email = $"🧠{GenerateRandomEmail()}",
                Password = "Password123"
            };

            var response = await _httpClient.PostAsJsonAsync("/api/auth/register", request);
            Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.BadRequest)
                                             .Or.EqualTo(HttpStatusCode.OK));
        }

        [OneTimeTearDown]
        public void TearDown()
        {
            _httpClient.Dispose();
        }
    }
}
